import copy

def find_empty_tile(state):
    """Find the position of the empty tile (0)"""
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j
    return None

def get_neighbors(state):
    """Get all possible next states by moving the empty tile"""
    neighbors = []
    empty_i, empty_j = find_empty_tile(state)
    
    # Possible moves: up, down, left, right
    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    for di, dj in moves:
        new_i, new_j = empty_i + di, empty_j + dj
        
        if 0 <= new_i < 3 and 0 <= new_j < 3:
            # Create new state by swapping tiles
            new_state = copy.deepcopy(state)
            new_state[empty_i][empty_j] = state[new_i][new_j]
            new_state[new_i][new_j] = 0
            neighbors.append(new_state)
    
    return neighbors

def is_goal(state, goal):
    """Check if current state is the goal state"""
    return state == goal

def dls(current, goal, depth_limit, path, visited):
    """Depth-Limited Search (helper for IDDFS)"""
    if is_goal(current, goal):
        return path + [current]
    
    if depth_limit <= 0:
        return None
    
    visited.add(str(current))
    
    for neighbor in get_neighbors(current):
        if str(neighbor) not in visited:
            result = dls(neighbor, goal, depth_limit - 1, path + [current], visited)
            if result is not None:
                return result
    
    return None

def solve_iddfs(initial, goal, max_depth=50):
    """Solve using Iterative Deepening DFS"""
    for depth in range(max_depth):
        visited = set()
        result = dls(initial, goal, depth, [], visited)
        if result is not None:
            return result
    return None

# Main execution
def main():
    # Example puzzle (you can change this)
    initial = [[1, 3, 2], [5, 0, 4], [7, 8, 6]]
    goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
    
    print("Initial state:")
    for row in initial:
        print(row)
    print("\nGoal state:")
    for row in goal:
        print(row)
    print("\nSolving with IDDFS...")
    
    solution = solve_iddfs(initial, goal)
    
    if solution:
        print(f"Solution found in {len(solution)-1} moves!")
        print("\nSolution path:")
        for i, state in enumerate(solution):
            print(f"Step {i}:")
            for row in state:
                print(row)
            print()
    else:
        print("No solution found within depth limit!")

if __name__ == "__main__":
    main()
